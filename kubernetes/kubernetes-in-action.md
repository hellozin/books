# Kubernetes In Action
Marko Luksa 지음

## 1부 쿠버네티스 개요

### 1장 쿠버네티스 소개

**쿠버네티스는 왜 쓸까?**

모놀로틱 서비스에서 마이크로 서비스로 옮겨가며 애플리케이션의 단위가 더 작고 단순해졌다. 하지만 그만큼 하나의 서비스가 더 많은 수의 애플리케이션으로 구성되면서 각 애플리케이션 간 관리 오버헤드가 발생하기 시작했다. 이러한 오버헤드를 줄이기 위해 K8S가 나오게 되지 않았을까?

마이크로 서비스의 주요 키워드는 독립 개발, 독립 배포 인 것 같다. 서비스를 나누는 단위도 배포 가능한 컴포넌트

**찾아보자**

- 모놀로틱 서비스가 마이크로 서비스로 바뀌면서 생기는 문제는 뭐가 있을까?
- 마이크로 서비스에서 REST API로 통신하는 것은 바로 떠오르는데 AMQP는 어떤 방식으로 사용되고 있을까?
- VM과 컨테이너의 차이는 뭘까?

### 2장 도커와 쿠버네티스 첫걸음

- 리눅스가 아닌 머신(맥이나 윈도우)에서 도커를 설치하면 리눅스 가상머신이 생성되고 가상머신 안에 도커 데몬이 구동된다.
- 도커의 빌드 프로세스는 도커 클라이언트가 아니라 도커 데몬에서 수행된다.
- 빌드 시 디렉터리 전체 파일이 데몬에 업로드 되기 때문에 데몬이 로컬로 실행중이지 않을 경우(맥이나 윈도우) 전체 파일 크기에 따라 업로드 시간이 길어질 수 있다.
- 빌드 디렉터리에 불필요한 파일을 추가하지 말자.
- `docker ps`보다 자세한 json 포멧의 결과를 보여주는 `docker inspect <container-name>`
- minikube : 로컬에서 간단하게 쿠버네티스를 조작해 볼 수 있는 단일 노드 클러스터 설치 도구
```
# 클러스터 시작
minikube start
```
>>> 나중에 다시 정리 !!!

### 3장 파드: 쿠버네티스에서 컨테이너 실행

#### 파드는 왜 필요할까?

컨테이너의 설계 목적 -> 단일 프로세스 (여러 프로세스 x)

#### 왜?

- 컨테이너는 관련이 없는 다른 프로세스는 관리(실패 시 재시작 등)하지 않는다.
- 모든 프로세스가 동일한 표준 출력으로 로그를 남겨 어떤 프로세스가 남긴 로그인지 파악이 어렵다.

#### 그렇다면

여러 프로세스 -> 여러 컨테이너, 즉 각 프로세스는 개별 컨테이너로 실행 

여러 컨테이너를 묶고 관리할 단위가 필요하다, **파드!**

파드를 통해 연관된 프로세스를 함께 실행하고 단일 컨테이너와 유사한 환경을 제공한다.

#### 어떻게?

같은 파드 내의 컨테이너는 부분 격리, 2장에서는 컨테이너가 서로 완벽하게 격리, 이제는 컨테이너 '그룹'이 서로 완벽하게 격리

파드 내 컨테이너는 아래 내용을 공유하도록 설정한다.

- 리눅스 네임 스페이스
- 네트워크 네임스페이스
- UTS(UNIX Timesharing System) 네임스페이스

이를 통해 같은 호스트 이름, 네트워크 인터페이스를 공유한다.

다만 파일시스템의 경우 대부분 이미지에 종속되기 때문에 다른 컨테이너와 완전히 격리된다.

이를 해결하기 위해 뒤에서 '볼륨'에 대해 알아본다!

#### 파드 내부의 네트워크 네임스페이스
